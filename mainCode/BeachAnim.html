
<!DOCTYPE html>
<html>
    <head>
    <meta charset="UTF-8">
    <title>BeachAnim</title>
    <style>
        body {
            background-color: #DDDDDD;
        }
        
        canvas {
            background-color: lightblue;
            display: block;
        }

        #canvasholder {
            border:2px solid black;
            float: left;
        }
    </style>
    <script>

        "use strict";  // gives improved error-checking in scripts.

        var canvas;    // The canvas element on which we will draw.
        var graphics;  // A 2D graphics context for drawing on the canvas.
        var pixelSize; // The size of a pixel in the coordinate system; set up by
                    //    applyWindowToViewportTransform function when it is called.
        var frameNumber = 0; // Which frame we are on... Used in animation.
        
        function draw() {
            graphics.clearRect(0,0,1000,1000);  // Clear the canvas, so it shows its background color.
            graphics.save();  // Push graphics context state onto a stack.

            applyWindowToViewportTransformation(-5,10,-1,14,true);

            drawScene();
            
            graphics.restore();  // Pop the saved graphics context state.   DO NOT FORGET THIS STEP!!!
        }
        
    function drawScene() {
        graphics.save();  // Save the CS so it can be restored later.

        graphics.scale(1,1);
        drawMainScene();
        
        graphics.restore();
    }
    function drawTree(x, y, trunkWidth, trunkHeight, foliageRadius) {
    graphics.save();

    // Draw the curved and lopsided tree trunk using Path2D
    let trunk = new Path2D();
    
    // Begin path for trunk, adapting the Java code logic
    trunk.moveTo(x - 1, y + 4);                            // Start at base left
    trunk.bezierCurveTo(                                   // Left side curve of the trunk
        x , y + 4,
        x + 0.3, y + 0.3,
        x - 2, y - 2
    );
    trunk.lineTo(x - 0.5, y - 1.3);                        // Root spike left
    trunk.lineTo(x + 0.6, y - 2.8);                        // Middle spike
    trunk.lineTo(x + 1, y - 1.4);                          // Root spike right
    trunk.lineTo(x + 2, y - 2);                          // Right side curve of trunk
    trunk.bezierCurveTo(                                   // Right side curve of the trunk
        x + 2, y - 2,
        x + 0.3, y + 0.3,
        x + 1, y + 4
    );

    // Set dark brown color and fill the trunk
    graphics.fillStyle = 'rgb(80, 35, 0)';
    graphics.fill(trunk);

    // Draw tree foliage (ellipse) - dark green
    graphics.fillStyle = 'rgb(0, 90, 0)';
    graphics.beginPath();
    graphics.ellipse(x+0.3, y + 3, foliageRadius * 3, foliageRadius * 3, 0, 0, Math.PI * 2); // Elliptical foliage
    graphics.fill();

    graphics.restore();
}
    function drawMainScene() {
        // The environment
        {
            graphics.save();
            let ground = new Path2D();
            let water = new Path2D();
            ground.moveTo(-10.0, 6.0);
            ground.lineTo(10.0, 6.0);
            ground.lineTo(10.0, -10.0);
            ground.lineTo(-10.0, -10.0);
            ground.closePath();
            water.moveTo(-4.0, 6.0);
            water.bezierCurveTo(2.0, 3.0, 5.0, 3.0, 9.0, 6.0);
            water.closePath();

            graphics.fillStyle = 'rgb(7, 168, 26)';
            graphics.fill(ground);
            graphics.fillStyle = 'rgb(0, 0, 255)'; 
            graphics.fill(water);
            graphics.restore();
        }
        //trees
        {
            graphics.save();
            //graphics.fillStyle="rgb(0, 102, 0)";
            drawTree(-2.5, 3, 2, 3, 0.6);  // Tree on the left
            drawTree(7, 3, 2, 4, 0.6);   // Tree on the right
            graphics.restore();
        }
        //seesaw
        {
        graphics.save();
        seesaw();
        //graphics.translate(5,10);
        graphics.restore();
        }
        {
            graphics.save();
            graphics.fillStyle="rgb(204, 55 , 178)";
            
            bar();
            graphics.restore();
        }
        {
            graphics.save();
            graphics.fillStyle="rgb(255, 255, 255)";
            drawPerson();
            graphics.restore();
        }

    }

    function drawBackground() {
        let ground = new Path2D();
        let water = new Path2D();
        ground.moveTo(-10.0, 3.0);
        ground.lineTo(10.0, 3.0);
        ground.lineTo(10.0, -10.0);
        ground.lineTo(-10.0, -10.0);
        ground.closePath();
        water.moveTo(-6.0, 3.0);
        water.bezierCurveTo(-0.5, 0.0, 0.0, -3.0, 5.0, 3.0);
        water.closePath();

        graphics.fillStyle = 'rgb(7, 168, 26)';
        graphics.fill(ground);
        graphics.fillStyle = 'rgb(0, 0, 255)'; 
        graphics.fill(water);
    }
    function seesaw(){
        graphics.save();
        graphics.fillStyle = "rgb(51, 102, 0)";
        graphics.beginPath();
        graphics.moveTo(0,2);
        graphics.lineTo(-1,0);
        graphics.lineTo(1,-0);
        graphics.closePath();
        graphics.fill();
        graphics.restore();
    }
    function bar() {
    graphics.save();                
    
    // Set the position for the bar
    graphics.translate(0, 2); // Move the bar up

    // Calculate the angle for rocking motion
    let angle = Math.sin(frameNumber * 0.05) * 0.3; // Adjust multiplier for speed and angle
    graphics.rotate(angle); // Rotate the bar

    graphics.fillStyle = "rgb(204, 55, 178)";
    graphics.fillRect(-2.5, -0.075, 5.0, 0.15); // Center the rectangle around (0, 2)

    graphics.restore();
}

function drawPerson(){
    graphics.save();
    graphics.fillOval(-2,3,0.5,0.5);
    graphics.beginPath();
    graphics.moveTo(-2,3);
    graphics.lineTo(-3,4);
    graphics.closePath();
    graphics.fill();
    graphics.restore();
}


    
    

        /**
        * Sets up a transformation in the graphics context so that the canvas will
        * show x-values in the range from left to right, and y-values in the range
        * from bottom to top.  If preserveAspect is true, then one of the ranges
        * will be increased, if necessary, to account for the aspect ratio of the
        * canvas.  This function sets the global variable pixelsize to be the
        * size of a pixel in the new coordinate system.  (If preseverAspect is
        * true, pixelSize is the maximum of its horizontal and vertical sizes.)
        */
        function applyWindowToViewportTransformation(left,right,bottom,top,preserveAspect) {
            var displayAspect, windowAspect;
            var excess;
            var pixelwidth, pixelheight;
            if (preserveAspect) {
                // Adjust the limits to match the aspect ratio of the drawing area.
                displayAspect = Math.abs(canvas.height / canvas.width);
                windowAspect = Math.abs(( top-bottom ) / ( right-left ));
                if (displayAspect > windowAspect) {
                    // Expand the viewport vertically.
                    excess = (top-bottom) * (displayAspect/windowAspect - 1)
                    top = top + excess/2
                    bottom = bottom - excess/2
                }
                else if (displayAspect < windowAspect) {
                    // Expand the viewport vertically.
                    excess = (right-left) * (windowAspect/displayAspect - 1)
                    right = right + excess/2
                    left = left - excess/2	
                }
            }
            graphics.scale( canvas.width / (right-left), canvas.height / (bottom-top) )
            graphics.translate( -left, -top );
            pixelwidth =  Math.abs(( right - left ) / canvas.width);
            pixelheight = Math.abs(( bottom - top ) / canvas.height);
            pixelSize = Math.max(pixelwidth,pixelheight);
        }  // end of applyWindowToViewportTransformation()

        function addGraphicsContextExtras(graphics) {
            graphics.strokeLine = function(x1,y1,x2,y2) {
            this.beginPath();
            this.moveTo(x1,y1);
            this.lineTo(x2,y2);
            this.stroke();
            }
            graphics.fillCircle = function(x,y,r) {
            this.beginPath();
            this.arc(x,y,r,0,2*Math.PI,false);
            this.fill();
            }
            graphics.strokeCircle = function(x,y,radius) {
            this.beginPath();
            this.arc(x,y,radius,0,2*Math.PI,false);
            this.stroke();
            }
            graphics.fillPoly = function() { 
                if (arguments.length < 6)
                return;
                this.beginPath();
                this.moveTo(arguments[0],arguments[1]);
                for (var i = 2; i+1 < arguments.length; i = i + 2) { 
                this.lineTo(arguments[i],arguments[i+1]);
                }
                this.closePath();
                this.fill();
            }
            graphics.strokePoly = function() { 
                if (arguments.length < 4)
                return;
                this.beginPath();
                this.moveTo(arguments[0],arguments[1]);
                for (var i = 2; i+1 < arguments.length; i = i + 2) { 
                this.lineTo(arguments[i],arguments[i+1]);
                }
                this.closePath();
                this.stroke();
            }
            graphics.fillOval = function(x,y,horizontalRadius,verticalRadius) {
            this.save();
            this.translate(x,y);
            this.scale(horizontalRadius,verticalRadius);
            this.beginPath();
            this.arc(0,0,1,0,2*Math.PI,false);
            this.restore();
            this.fill();
            }
            graphics.strokeOval = function(x,y,horizontalRadius,verticalRadius) {
            this.save();
            this.translate(x,y);
            this.scale(horizontalRadius,verticalRadius);
            this.beginPath();
            this.arc(0,0,1,0,2*Math.PI,false);
            this.restore();
            this.stroke();
            }
            graphics.getRGB = function(x,y) {
                var color = this.getImageData(x,y,1,1);
                return color.data;
            }
        }    // end of addGraphicsContextExtras()

        /**
        *  Draw one frame of the animation, and call requestAnimationFrame() to arrange
        *  for the function to be called again.
        */
        function doFrame() {
            frameNumber++;
            // YOU CAN ADD UPDATE OTHER DATA FOR THE FRAME HERE.
            draw();
            requestAnimationFrame(doFrame);
        }
    
        /**
        * The init() funciton is called after the page has been
        * loaded.  It initializes the canvas and graphics variables.
        * It calles addGraphicsContextExtras(graphics) to add the extra
        * drawing functions to the graphics context, and it calls draw()
        * to draw on the canvas.
        */
        function init() {
            try {
                canvas = document.getElementById("canvas");
                graphics = canvas.getContext("2d");
            } catch(e) {
                document.getElementById("canvasholder").innerHTML =
                "Canvas graphics is not supported.<br>" +
                "An error occurred while initializing graphics.";
            }
            addGraphicsContextExtras(graphics);  // Add the extra features to the graphics context
            draw();  // Call draw() to draw on the canvas.
            if (!window.requestAnimationFrame) { // This is for Internet Explorer 9
                window.requestAnimationFrame = function(callback) {
                    setTimeout(callback, 1000/60);    
                }
            }
            requestAnimationFrame(doFrame);
        }
    </script>
    </head>
    <body onload="init()"> <!-- the onload attribute here is what calls the init() function -->

        <h2>Beach Animation</h2>

        <noscript>
            <!-- This message will be shown in the page if JavaScript is not available. -->
        <p>JavaScript is required to use this page.</p>
        </noscript>

        <div id="canvasholder">
        <canvas id="canvas" width="1000" height="1000">
            <!-- This message is shown on the page if the browser doesn't support the canvas element. -->
        Canvas not supported.
        </canvas>
    </div>

    </body>
</html>